# Logic Magnets Game

## الوصف
لعبة المغناطيسات المنطقية هي لعبة ألغاز تعتمد على تحريك مغناطيسات ذات تأثيرات مختلفة (الجذب والطرد) لتحقيق هدف معين على لوحة اللعبة. يقوم اللاعب بتحريك المغناطيسات على اللوحة لحل الألغاز، مع الأخذ بعين الاعتبار تأثير كل نوع من المغناطيسات على القطع الأخرى.

### 1. فضاء الحالات State Space:
يقوم تابع `possibleMoveAlternative` بحساب جميع الحركات المحتملة للقطع المغناطيسية (جذب ودفع) على لوحة اللعبة، وتحديد الحالات التي يمكن لكل قطعة أن تتحرك إليها. حيث يتم تعريف مصفوفة `moves` لتخزين الحالات التي سيعيدها التابع في النهاية ويستدعي التابعين `getAttractCoord` و`getRepelCoord` للحصول على إحداثيات مكان القطعتين المغناطيسيتين، الجاذبة والدافعة، إذا كانت موجودة. يقوم بحساب الحركات للقطعة الجاذبة إذا كانت الخلية `(i, j)` هي خلية يمكن للقطعة الجاذبة أن تتحرك إليها (`canMove(i, j)`) يقوم بإنشاء نسخة عميقة من الكائن الحالي (`current_move = deepcopy(self)`) ثم يغير نوع الخلية في الإحداثيات `(i, j)` ليأخذ نوع الخلية التي كانت تحتوي على القطعة الجاذبة. بعد ذلك، يتم تغيير الخلية الأصلية (التي كانت تحتوي على القطعة الجاذبة) إلى نوع `'road'` ثم يتم استدعاء التابع `moveAttractCells` لتحريك الخلايا المرتبطة بالقطعة الجاذبة في اللوحة وفي النهاية يتم إضافة الحركة المحتملة إلى قائمة `moves`.
بنفس الطريقة، يقوم بحساب الحركات للمغناطيس النافر حيث يتم استدعاء التابع `moveRepelCells` لتحريك الخلايا المرتبطة بالقطعة الدافعة في اللوحة وأيضا يتم إضافة الحركة المحتملة إلى قائمة `moves`. في النهاية، يتم إرجاع قائمة `moves` التي تحتوي على جميع الحركات المحتملة التي يمكن أن تقوم بها القطع المغناطيسية.

### 2. تمثيل الحالة:
عبارة عن رقعة `n*n` وبسبب أن اللعبة النظامية تكون رقعتها غير منتظمة تم وضع خلايا من نوع `block` لحل هذه المشكلة. يتم تمثيل الحالة باستخدام كائن من فئة `State`، التي تحتوي على:
- **الصفوف (rows):** عدد الصفوف في اللوحة.
- **الأعمدة (cols):** عدد الأعمدة في اللوحة.
- **اللوحة (board):** مصفوفة تحتوي على الخلايا، حيث يتم تمثيل كل خلية بواسطة كائن من فئة `Cells` التي تحتوي على:
  - **الإحداثيات (x, y):** موقع الخلية على اللوحة.
  - **نوع الخلية (current_type):** يمكن أن يكون `"طريق"` (road)، `"حديد"` (iron)، `"مغناطيس جذب"` (attract)، `"مغناطيس طرد"` (repel)، أو غيرها.
  - **نوع الخلية الأساسي (initial_type):** نوع الخلية في البداية.
  - **الخلية المحلولة (is_Solve):** هل تم حل هذه الخلية أم لا.

### 3. الحالة الابتدائية:
الحالة الابتدائية للعبة تتضمن لوحة تمثل توزيع الخلايا في بداية اللعبة، مع تحديد مواقع المغناطيسات (الجذب والطرد) والعناصر الأخرى مثل الحديد والحواجز. يتم إنشاء الحالة الابتدائية في صف `LevelManager` عند اختيار مستوى معين، حيث يتم تحديد الرقعة الأولية للوحة بناءً على المستوى الذي يختاره المستخدم. بعد اختيار المستوى، يتم اختيار إذا أراد اللاعب اللعب أو أراد لخوارزميات البحث (DFS أو BFS) حل اللعبة.

### 4. العمليات:
يتم تحريك المغناطيسات (الجذب والطرد) على اللوحة والتفاعل مع العناصر (الحديد والمغناطيسات الموجودة في الرقعة) إما عن طريق إدخالات المستخدم أو عن طريق خوارزميات البحث (DFS & BFS). تتضمن العمليات:

#### 1. التحريك (move):
- يتم تحريك المغناطيس (سواء جذب أو طرد) من موقع إلى آخر على اللوحة.
- في class `Game`، تُستخدم دالة `move()` لتغيير موقع المغناطيس وتحريك العناصر الأخرى المتأثرة.

#### 2. الجذب (attract):
- يتم تحريك المغناطيس الجاذب من خلال تابع `moveAttract` الذي يحصل على إحداثيات المغناطيس الجاذب عن طريق تابع `getAttractCoord` في class `State`، ويستدعي التابع `move` لنقل المغناطيس.
- يقوم تابع `attract` في class `Game` بتطبيق المنطق الخاص بجذب الكرات الحديدية والمغناطيس النافر في حال وجوده، ويسحب الحديد والعناصر الأخرى في صفه أو عموده خطوة واحدة.

#### 3. الطرد (repel):
- يتم تحريك المغناطيس النافر من خلال تابع `moveRepel` الذي يحصل على إحداثيات المغناطيس النافر عن طريق تابع `getRepelCoord` في class `State`، ويستدعي التابع `move` لنقل المغناطيس.
- يقوم تابع `repel` في class `Game` بتطبيق المنطق الخاص بالتنافر لإبعاد الكرات الحديدية والمغناطيس الجاذب في حال وجوده، ويقوم بدفع الحديد والعناصر الأخرى في صفه أو عموده خطوة واحدة.

#### 4. التحقق من الفوز (CheckWin):
- إذا كانت هناك خلايا من النوع `"road"` (طريق) التي تعتبر `is_Solve` (مخصصة للحل)، فهذا يعني أن اللعبة لم تنتهِ بعد حيث توجد خلايا بحاجة إلى أن تكون قد تم حلها أو المرور عليها.
- أما إذا كانت جميع الخلايا التي تحتوي على `"road"` ليست جزءًا من الحل (`is_Solve == False`)، فإن ذلك يعني أن اللعبة قد انتهت بنجاح (تم الوصول إلى حالة الفوز).

### 5. البحث عن الحل (BFS/DFS):
- تتم هذه العملية باستخدام دالة `BFSsearchDFS()` في class `Game`، حيث يتم التبديل بين الحالتين باستخدام خوارزمية البحث المحددة، وتسجيل الحركات الممكنة في قائمة الحركات `possible_moves`.
- بنية المعطيات عبارة عن list تسمى `possible_moves` لتخزين الحركات الممكنة حيث يبدأ التابع بحلقة `while` تستمر في العمل طالما أن هناك حركات ممكنة مخزنة في القائمة `possible_moves`. هذا يعني أن اللعبة لم تصل إلى حالة فوز بعد. إذا كانت قيمة المتغير `algo` هي `'BFS'`، فهذا يعني أنه سيتم استخدام خوارزمية `BFS`. في هذه الحالة، يتم أخذ أول حركة من القائمة `possible_moves` باستخدام `pop(0)` وحذف العنصر الأول. أما إذا كانت `DFS`، يتم أخذ آخر حركة من القائمة `possible_moves` باستخدام `pop()` لحذف العنصر الأخير.
- بعد اختيار الحركة المناسبة، يتم التحقق مما إذا كانت الحالة الحالية هي حالة فوز باستخدام التابع `checkWin()`. إذا تم التحقق من أن الحالة هي حالة فوز، يتم إضافة الحالة الحالية إلى قائمة `visited_state` أي الحالات التي تم زيارتها ثم يتم طباعة جميع الحالات التي تم زيارتها. بعد الوصول إلى حالة الفوز يخرج من الحلقة.
- إذا كانت الحالة الحالية لم يتم زيارتها من قبل، يتم إضافتها إلى قائمة `visited_states` ويتم استدعاء التابع `possibleMovesAlternative()` للحصول على جميع الحركات الممكنة من الحالة الحالية. إذا لم تكن الحركة قد تم زيارتها من قبل (أي أنها ليست موجودة في `visited_states`)، يتم إضافتها إلى قائمة `possible_moves` حتى يتم أخذها في الاعتبار في الحركات التالية.
- كل عملية يتم تنفيذها على نسخة من الحالة باستخدام `deepcopy()` لضمان عدم تعديل الحالة الأصلية أثناء اللعبة.

### 4. الحالة النهائية:
هي الحالة التي تحقق فيها اللعبة الهدف المطلوب، وهو تحريك المغناطيسات بطريقة تجعل كل العناصر المطلوبة (مثل الحديد) تصل إلى الخلايا المحددة على اللوحة. يتم التحقق من الحالة النهائية من خلال فحص كل الخلايا على اللوحة باستخدام دالة `checkWin()` في فئة `State`. إذا كانت جميع الخلايا التي تحتوي على علامة "حل" قد تم ملؤها بشكل صحيح، يتم اعتبار اللعبة قد تم حلها.
